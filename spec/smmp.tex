\documentclass[%
%reprint,
%superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
preprint,
%showpacs,preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
amsmath,amssymb,
aps,
%pra,
prb,
%rmp,
%prstab,
%prstper,
floatfix,
]{revtex4-1}


\usepackage{graphicx}% Include figure files
%\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
\usepackage{amsmath}
\usepackage{subfigure}

\begin{document}

\preprint{Version 0.3.5}

\title{SMMP: A Secure Multi-Party Messaging Protocol}% Force line breaks with \\

\author{David R. Andersen}
 \email{k0rx@uiowa.edu}
 \altaffiliation[Also at ]{Department of Physics and Astronomy, The University of Iowa.}%Lines break automatically or can be forced with \\
\author{Mark S. Andersland}
 \affiliation{Department of Electrical and Computer Engineering, The University
 of Iowa, Iowa City, IA 52242}
\author{Tycho J. Andersen}
 \affiliation{Canonical, Inc.\\ Madison, WI 53703}

\date{\today}% It is always \today, today,
             %  but any date may be explicitly specified

\begin{abstract}
We describe a new secure, multi-party, synchronous communication protocol.
The protocol follows a peer-to-peer model and provides perfect forward
secrecy, perfect future secrecy, and plausible deniability for participants in
the conversation, as long as at least two participants are honest.
The protocol uses the elliptic-curve Diffie-Hellman key agreement
protocol to generate a set of shared secrets between a group of
participants. The group is initially formed by an Organizer.
The Organizer role is abandoned when key agreement is accomplished, leaving
the original organizer as a one of $N$ peers in the messaging network.
All setup operations prior to key agreement can take place over an insecure
channel.
\end{abstract}

\pacs{73.20.Mf}% PACS, the Physics and Astronomy
                             % Classification Scheme.
%\keywords{Suggested keywords}%Use showkeys class option if keyword
                              %display desired
\maketitle

%\tableofcontents
\section{\label{sec:Introduction}Introduction}
Secure multi-party messaging has been an elusive goal of security researchers
for a long time. The initial group off-the-record (GOTR) `virtual server'
approach\cite{ref:bian} was deemed unsatisfactory
because it has the unfortunate drawback of not permitting all participants to
confirm that they were receiving unmodified copies of all messages.
A further attempt to solve this problem\cite{ref:goldberg} was incomplete
because of the lack of a simple, secure key-agreement
strategy. Work on the problem
continues to date, most notably with\cite{ref:cryptocat}, however the
key-agreement problem remains unsolved. Liu \textit{et.al.}\cite{ref:liu}
recently improved the security of GOTR/mpOTR using a Burmester-Desmedt group
key agreement mechanism.

In this paper, we describe a novel secure multi-party messaging protocol with a
simple key-agreement algorithm that provides perfect forward secrecy (PFS),
perfect future secrecy (PFuS),
and plausible deniability (PD) for participants in a group conversation. Our protocol
is a peer-to-peer protocol, whereby each
participant (peer) contributes new
key material to the group key set with each message sent. The group is
initially constituted by an Organizer. Following the formation of the group, the
Organizer role is abandoned and the initial Organizer assumes a peer role, the
same as all other Participants.

\section{\label{sec:keypoints}Key Points}
\begin{itemize}
\item Each group key agreement is facilitated by an Organizer, who is also
participant $P_0$. Following the key agreement stage, the Organizer is no longer
required. The Organizer data is securely deleted and the Participant
$P_0$ role is that of a peer like any other
participant.
\item Elliptic curve Diffie-Hellman key operations are performed on curve25519
with 32 byte
public and private keys.
\item The protocol is synchronous. A method for resynchronizing those
participants that lose synchronization due to lost packets from collisions or
transport failure is included in the protocol.
\item Group setup is via an insecure channel.
\item Putative participants authenticate to the Organizer, prior to
activation of the group protocol.
\item Participants may not be added to the group. This would
require a reinitialization of the group secrets. A Participant may leave the
group.
\item A uniform message transcript is assured over all participants via a
conversation digest that is updated with each message. If the digest does not
match what a receiver expects, a resynchronization of the protocol is requested.
\item The underlying symmetric encryption algorithm used for communication is
unspecified.
\end{itemize}

\section{\label{sec:background}Background}
Various protocols exist for facilitating secure one-on-one messaging, including
Off the Record Messaging (OTR)\cite{ref:otr1,ref:raimondo,ref:otr2,ref:otr3,ref:otr}, Silent Circle Instant Messaging Protocol
(SCIMP)\cite{ref:scimp}, and Axolotl\cite{ref:axolotl}. Each of these protocols
provides security through the use of ephemeral keys for symmetric encryption.
The method of generating and exchanging these keys varies widely between the
three protocols. All of the protocols provide forward
secrecy. Some also provide plausible deniability. And one (Axolotl) also
provides perfect future secrecy (compromise of the current keyset does not cause
compromise of future keysets). However, each of these protocols is limited to
the one-on-one messaging case.

OTR was the first such protocol. It is based on an Advertise $\rightarrow$
Acknowledge $\rightarrow$ Use method for key updating. OTR has been widely used
for secure instant messaging and applications containing OTR plugins are
available for XMPP, IRC, and other messaging systems.

SCIMP is a proprietary protocol developed by Silent Circle as their solution for
providing secure communications as part of their product line. The key
advancement algorithm for SCIMP is essentially a hash. Each symmetric encryption
key is hashed to obtain the key for the next ratchet step. As a result, a key
compromise at any point will permit an attacker to follow the conversation from
that point on.

Axolotl is the first one-on-one messaging protocol to provide future secrecy. In
this protocol, randomly-generated key data is mixed in to the ratchet state with
each message send/receive operation, so that a compromised keyset permits an
attacker access to only one message. Following the conversation requires a new
key compromise with each message sent.

The first proposal for a secure group $(N \ge 3)$ messaging protocol was that of
Bian \textit{et.al.}\cite{ref:bian} [Group Off The Record (GOTR)]. The protocol is based on a virtual server,
a user that sets up a secure one-on-on channel with each member of the group.
When members of the group who are not the virtual server wish to communicate
with each other, they relay their messages through the virtual server. The
problem with this approach is that there is no way for users to verify that they
are getting a complete transcript of the group conversation. Trust in the
virtual server is required, and a compromise of the virtual server would permit
an attacker to follow the entire conversation, as well as learn the membership
of the group.

A second proposal for a secure group messaging protocol was made by Goldberg
\textit{et.al.}\cite{ref:goldberg} [multi-party Off The Record (mpOTR)].
While this protocol solved some of the
problems associate with the Bian messaging scheme, it did not give a complete
key-agreement algorithm. Thus far, to our knowledge, the key-agreement problem
has not been solved. As a result, this protocol has never been successfully
implemented.

An improvement of the security of the GOTR/mpOTR protocol was made by Liu
\textit{et.al}\cite{ref:liu} using a Burmester-Desmedt\cite{ref:burmester}
group key agreement
protocol. The Liu group demonstrated their protocol with a
Pidgin\cite{ref:pidgin} plugin.

In this paper, we present a secure, peer-to-peer multi-party messaging protocol
(SMMP) that provides PFS, PFuS, and PD, and has a simple key agreement
algorithm. The protocol allows all group members to confirm that they are
receiving a complete transcript of the group conversation, and provides a
robust mechanism for resynchronization of the ratchet state if messages are lost
because of failure of the underlying transport mechanism.

\section{\label{sec:notation}Notation}
The following notation is used:
\begin{itemize}
\item $N$ is the total number of participants in the group (including the
Organizer)
\item $\oplus$ is the XOR operator
\item $\{N_i\}$ is the set of all $N_i$ and $\{N_i\}_m = N_m$.
\item $\oplus_{j \ne i} \, x_j$ means XOR of all $x_j$ except $x_i$.
\item  $\oplus_i \, x_i$ means XOR of all $x_i$.
\item $\mathcal{\hat{A}}_i$ is the ratchet state for
participant $P_i$.
\item $||$ is the concatenation operator
\item Lower case keys are private ECDH keys.
\item Upper case keys are public ECDH keys.
\item hash() is a secure, one-way cryptographic hash function.
\item hmac$(k,m)$ is a secure hashing message authentication function that
hashes a message $m$ using key $k$.
\item KDF() is a secure key derivation function, \textit{e.g.} pbkdf2.
\item $c = e(k, m)$ and $m = d(k,c)$ are the underlying (unspecified) symmetric
encryption and decryption algorithms that use a key $k$ to transform a plaintext
$m$ into ciphertext $c$ and \textit{vice versa}.
\item MK is a master key from which the initial ratchet state
$\mathcal{\hat{A}}_i$ is computed by each participant $P_i$. This parameter is
securely erased upon computing the initial ratchet state.
\item $X$ is the generator for curve25519 and ECDH() is the Diffie-Hellman
operator on curve25519, \textit{i.e.} for private key $u$, the
corresponding public key is $U = \mathrm{ECDH}(u, X)$. The shared secret between
$y$ and $z$ is then $ \mathrm{ECDH}(y,Z) = \mathrm{ECDH}(z,Y) =
\mathrm{ECDH}(y,\mathrm{ECDH}(z, X))$.
\end{itemize}

\section{\label{sec:protocolstate}Protocol State}
Each Participant $P_j$ will maintain the following state variables in persistent
storage:
\begin{itemize}
\item RK - the root key
\item HK - the header key
\item NHK - the next header key
\item mk - the message key
\item $v$ - the group private ratchet key
\item $\mathrm{conv\_digest}$ - the digest of all conversation messages so far
\item $r_j$ - the participant private ratchet key (for participant $P_j$,
$\mathrm{ECDH}(r_j, X) = R_j$)
\item $\{R_i\}$ - the set of public ratchet keys from each participant $P_i$
\item $i$ - Participant $P_j$'s participant index number
\item $N$ - the group size
\item $\mathrm{group\_name}$ - the group name (this may be different for each Participant)
\item $\mathrm{resync\_required}$ - a flag used to determine if a resynchronization of the
ratchet state is required
\end{itemize}

\section{\label{sec:keyagreement}Key Agreement}
The Organizer and Participants complete the following steps:
\begin{enumerate}
\item Participant $P_0$ establishes himself as the group Organizer $O$ and solicits
keys from other potential participants.
\item Organizer $O$ determines the total number of participants $N$.
\item Organizer $O$ assigns a participant index number $i$ to each
participant.
\item Organizer $O$ generates elliptic curve Diffie-Hellman (ECDH) persistent group
identity, and ephemeral group handshake
keys $(u, U )$ and $(w, W)$.
\item Organizer $O$ forwards $U$, $W$, $N$, and $i$ to each participant $P_i$.
\item Each participant $P_i$ generates ECDH
persistent identity, ephemeral handshake and ephemeral ratchet keys $(b_i, B_i)$,
$(k_i, K_i)$, and $(r_i, R_i)$.
\item Each participant $P_i$ forwards $B_i$ and $K_i$ to Organizer $O$.
\item Each participant $P_i$ forwards $R_i$ to all other participants in the
group.
\item Organizer $O$ authenticates the identity of each participant $P_i$ with
identity key $B_i$.
\item Each participant $P_i$ authenticates the group identity key $U$ with Organizer
$O$.
\item Organizer $O$ computes:\\
$L_i$ = $\mathrm{hash}(\mathrm{ECDH}(u, K_i) \,
|| \, \mathrm{ECDH}(w, B_i) \, || \, \mathrm{ECDH}(w, K_i))$,\\
$G_i = \mathrm{ECDH} (w, R_i) \, \oplus \, \oplus_{j \ne i} \, L_j$.
\item Organizer $O$ forwards $G_i$ to participant $P_i$ for all participants.
\item Participant $P_i$ computes:\\
$\mathrm{MK} = \mathrm{hash}(\mathrm{ECDH}(k_i, U) \, ||
\, \mathrm{ECDH}(b_i, W) \, || \, \mathrm{ECDH}(k_i, W) \oplus \, G_i \, \oplus
\, \mathrm{ECDH}(r_i, W)$
\item Participant $P_i$ computes his/her initial ratchet state $\mathcal{\hat{A}}_i$:\\
$\mathrm{RK} = \mathrm{KDF}(\mathrm{MK}, 0\mathrm{x}00)$, \\
$\mathrm{HK} = \mathrm{KDF}(\mathrm{MK}, 0\mathrm{x}01)$, \\
$\mathrm{NHK} = \mathrm{KDF}(\mathrm{MK}, 0\mathrm{x}02)$, \\
$\mathrm{mk} = \mathrm{KDF}(\mathrm{MK}, 0\mathrm{x}03)$, \\
$v = \mathrm{KDF}(\mathrm{MK}, 0\mathrm{x}04)$, \\
$\mathrm{conv\_digest} = 0\mathrm{x}00 * 32$, \\
$r_i$ from step 6, \\
$\{R_i\}$ from participants, \\
$N$ from Organizer $O$, \\
$i$ from Organizer $O$, \\
resync\_required = \textit{False}.
\item The Organizer role is complete and all Organizer data
is securely erased by participant $P_0$.
\end{enumerate}

\section{\label{sec:sending}Sending Messages}
Participants wanting to send a message will proceed as follows:
\begin{enumerate}
\item When a participant $P_j$ wishes to communicate with the other
participants, he forms a message $m$.
\item Participant $P_j$ generates a new ephemeral ratchet key
$(r_j^{new},R_j^{new})$.
\item Participant $P_j$ computes a new conversation digest
$ \mathrm{conv\_digest} = \mathrm{hash}(m) \, \oplus \, \mathrm{conv\_digest}$.
\item For all $i \ne j$, participant $P_j$ computes the set of $N-1$ preliminary
ciphertexts $c_{hi} = e(\mathrm{HK}, j
\, || \, R_j^{new} \, \oplus \, \mathrm{hash}(\mathrm{ECDH}(r_j, R_i) \, \oplus
\, \mathrm{conv\_digest})$ and the
set of $N-1$ preliminary ciphertexts
$c_{mi} = e(\mathrm{mk}, m)$.
He the forms $c_i^\prime = c_{hi} \, || \, c_{mi}$.
\item Participant $P_j$ computes the set of $N-1$ hmacs $c_{hmaci} = \mathrm{hmac}(v, c_i^\prime)$.
\item Participant $P_j$ forms the set of $N-1$ ciphertexts $c_i = c_i^\prime \, || \, c_{hmaci}$.
\item Participant $P_j$ updates his/her ratchet state $\mathcal{\hat{A}}_j$ as
follows:\\
$(r_i, R_i) = (r_i^{new}, R_i^{new})$, \\
$\mathrm{RK} = \mathrm{hash}(\mathrm{RK} \, || \, \mathrm{ECDH}(v, \oplus_i
\, R_i))$, \\
$\mathrm{HK} = \mathrm{NHK}$, \\
$\mathrm{NHK} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}02)$, \\
$\mathrm{mk} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}03)$.
\item Participant $P_j$ sends $c_i $ to participant $P_i$ for all participants.
\end{enumerate}

\section{\label{sec:receiving}Receiving Messages}
Participants receiving a message will proceed as follows:
\begin{enumerate}
\item Upon receipt of a ciphertext $c$, participants $P_j$ separates $c$ into
$c^\prime$ and $c_{hmac}$ parts.
\item Participant $P_j$ tests if $\mathrm{hash}(v, c^\prime) = c_{hmac}$. If
they do not match, he/she raises a Bad\_HMAC exception and goes no further.
\item Participant $P_j$ splits $c^\prime$ into header $c_h$ and message $c_m$ components
and obtains $q \, || \, R =
d(\mathrm{HK}, c_h)$ and $m = d(\mathrm{mk},
c_m)$. If either of these operations fail, he/she raises a Message\_Undecryptable
exception, sets the resync\_required flag \textit{True},
and passes $c^\prime$ and control to the message-received housekeeping routine described in
Section \ref{sec:receivehousekeeping}.
\item Participant $P_j$ computes a new conversation digest
$\mathrm{conv\_digest} = \mathrm{hash}(m) \, \oplus \, \mathrm{conv\_digest}$.
\item Participant $P_j$ sets $R_q = R \, \oplus \,
\mathrm{hash}(\mathrm{ECDH}(r_j, R_q)) \, \oplus \, \mathrm{conv\_digest}$.
\item Participant $P_j$ updates his/her ratchet state $\mathcal{\hat{A}}_i$ as
follows: \\
$\mathrm{RK} = \mathrm{hash}(\mathrm{RK} \, || \, \mathrm{ECDH}(v, \oplus_i
\, R_i))$, \\
$\mathrm{HK} = \mathrm{NHK}$, \\
$\mathrm{NHK} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}02)$, \\
$\mathrm{mk} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}03)$.

\end{enumerate}

\section{\label{sec:im}One-On-One Messaging Within SMMP}
Participants in the group may exchange one-on-one messages with other group
participants using the group infrastructure. If participant $P_i$ wishes to
message participant $P_j$, he/she proceeds as follows:
\begin{enumerate}
\item Participant $P_i$ forms a message $m$.
\item If this is the first private message with $P_j$, participant $P_i$ makes
a copy of his current private ratchet key $r_i$
($s_i$) as well as participant $P_j$'s current public ratchet key $R_j$ ($S_j$).
If this is not the first private message $P_i$ has exchanged with $P_j$,
$s_i$ and $S_j$ already exist.
\item Participant $P_i$ generates a new one-on-one ratchet key $(t_i, T_i)$.
\item Participant $P_i$ forms preliminary ciphertexts $c_h = e(v, S_j), 0\mathrm{x}01
\, || \, T_i)$ and $c_m = e(\mathrm{ECDH}(s_i, S_j), m)$.
\item Participant $P_i$ forms $c^\prime = c_h \, || \, c_m$ and computes $c_{hmac} =
\mathrm{hmac}(v, c^\prime)$.
\item Participant $P_i$ sends $c = c^\prime \, || \, c_{hmac}$ to $P_j$.
\item Decryption will need to be added to the housekeeping section.
\end{enumerate}

\section{\label{sec:housekeeping}Protocol Housekeeping}
Here we list several protocol housekeeping operations that may be necessary.
The list may be extended if other useful operations are identified.

\subsection{\label{sec:receivehousekeeping}Message Received Housekeeping}
Housekeeping messages will be routed based on a one-byte header prepended to the
payload of the housekeeping message. The byte values and their corresponding
housekeeping tasks are (currently there are 4): \\

\begin{centering}
\begin{tabular}{|c|c|c|}
\hline
Byte Value & Housekeeping Task & Location \\
\hline
$0\mathrm{x}00$ & Resynchronizing the Ratchet State  & Section \ref{sec:receiveresync}\\
$0\mathrm{x}01$ & Instant Messaging Within SMMP & Section \ref{sec:imdecrypt}\\
$0\mathrm{x}02$ & Adding Members To the Group & Section \ref{sec:additions}\\
$0\mathrm{x}03$ & Removing Members From the Group & Section \ref{sec:removal}\\
\hline
\end{tabular} \\
\end{centering}
\bigskip
To determine the proper routing, the
participant proceeds as follows:
\begin{enumerate}
\item Participant $P_i$ computes $b \, || \, m = d(v, c^\prime)$. He/she then
finds the value corresponding to byte $b$ in the table above, and sends message
$m$ and control to that section.
\end{enumerate}
\subsubsection{\label{sec:receiveresync}Resynchronizing the Ratchet State: $b =
0\mathrm{x}00$}
It is possible, during communication within the group, that a participant's
ratchet state may become unsynchronized. Transport layer failures due to lost
messages or message collisions can cause a participant to be unsynchronized. If
this is the case, a Message\_Undecryptable exception will be raised
and control of the decryption will be passed here. The receiving participant
will then proceed as follows:
\begin{enumerate}
\item Participant $P_j$ sets $v = m$.
\item Participant $P_j$ computes $\{r_i\} = \{\mathrm{hash}(i)\}$.
\item Participant $P_j$ updates his/her ratchet state
$\mathcal{\hat{A}}_j$ as follows:\\
$\{R_i\} = \{\mathrm{ECDH}(r_i, X)\}$, \\
$\mathrm{RK} = \mathrm{hash}(\oplus_i \, R_i \, || \, \mathrm{ECDH}(v, \oplus_i
\, R_i))$, \\
$\mathrm{HK} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}01)$, \\
$\mathrm{NHK} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}02)$, \\
$\mathrm{mk} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}03)$, \\
$\mathrm{conv\_digest} = 0\mathrm{x}00 * 32$, \\
$\mathrm{resync\_required} = False$.
\end{enumerate}

\subsubsection{\label{sec:imdecrypt}Decrypting Private Messages Within SMMP: $b =
0\mathrm{x}01$}

tbd...

\subsubsection{\label{sec:additions}Adding Members To the Group: $b =
0\mathrm{x}02$}

tbd...
\subsubsection{\label{sec:removal}Removing Members From the Group: $b =
0\mathrm{x}03$}

tbd...

\subsection{\label{sec:sendhousekeeping}Message Send Housekeeping}
It may be necessary at some point to send housekeeping messages. This section
describes procedures to be followed in this case.

\subsubsection{\label{sec:sendresync}Resynchronizing the Ratchet State:
resync\_required = True}
When the resync\_required flag is set to \textit{True}, the ratchet state is
unsynchronized, and decrypting further conversation messages is impossible.
A participant wishing to correct this situation should follow the following
procedures (this may be automated):
\begin{enumerate}
\item Participant $P_j$ generates a new group private ratchet key $v^{new}$.
\item participant $P_j$ computes preliminary ciphertext $c^\prime = e(v, 0\mathrm{x}00
\, || \, v^{new})$.
\item Participant $P_j$ computes hmac $c_{hmac} = \mathrm{hmac}(v, c^\prime)$.
\item Participant $P_j$ forms $c = c^\prime \, || \, c_{hmac}$.
\item Participant $P_j$ delays according to a backoff algorithm
that should be transport-specific and is unspecified here.
\item Participant $P_j$ tests resync\_required to see if it is still
\textit{True}. If not, a resynchronization message was received and no further
action is necessary. If \textit{True}, participant $P_j$ continues with the next
step.
\item Participant $P_j$ broadcasts $c$ to all participants $P_i$.
\item Participant $P_j$ computes $\{r_i\} = \{\mathrm{hash}(i)\}$.
\item Participant $P_j$ updates his/her ratchet state
$\mathcal{\hat{A}}_j$ as follows:\\
$v = v^{new}$, \\
$\{R_i\} = \{\mathrm{ECDH}(r_i, X)\}$, \\
$\mathrm{RK} = \mathrm{hash}(\oplus_i \, R_i \, || \, \mathrm{ECDH}(v, \oplus_i
\, R_i))$, \\
$\mathrm{HK} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}01)$, \\
$\mathrm{NHK} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}02)$, \\
$\mathrm{mk} = \mathrm{KDF}(\mathrm{RK}, 0\mathrm{x}03)$, \\
$\mathrm{conv\_digest} = 0\mathrm{x}00 * 32$, \\
$\mathrm{resync\_required} = False$.
\end{enumerate}

\section{\label{sec:analysis}Security and Efficiency Analysis}

\subsection{\label{sec:securitymodel}Security Model}
Following the work of Goldberg, \textit{et.al.}\cite{ref:goldberg}, we propose a
security model with the following attributes:
\begin{itemize}
\item Confidentiality - While a participant is willing to disclose certain
information to members of a group, the group communication should remain hidden
to those outside the group.
\item Entity authentication - Prior to joining the group, members should be
authenticated so that during the group conversation, group members can be
confident that messages purportedly from a particular group member were
actually authored by that group member.
\item Origin authentication - All messages should be authenticated as to their
participant of origin.
\item Forward secrecy - The protocol should provide PFS for all messages sent as
part of the group communication.
\item Future secrecy - The protocol should provide PFuS for all future messages
to be sent as part of the group communication.
\item Plausible Deniability - The protocol should provide PD such that a
transcript of the group conversation cannot be used to prove the membership in
the group of any participant after the conversation has completed.
\end{itemize}

Further, we adopt the same threat model as did Goldberg
\textit{et.al}\cite{ref:goldberg}. In particular, we analyze the robustness of
the protocol to three types of adversaries, a security adversary, a consensus
adversary, and a privacy adversary. We further assume that all group
participants will follow the protocol faithfully. This assumption is valid for
both honest participants (they have an interest in a secure group conversation),
as well as dishonest participants (they have an interest in not revealing their
dishonesty during the conversation).  Online judges (members of the group) can
be considered a subset of the dishonest participants. Both online and offline
judges will be used to determine if the goals of the protocol have been met.

\subsection{\label{sec:networkmodel}Network Model}
The network model used by SMMP is that of a fully-connected graph.
Operation of the network may be simplified somewhat by using an echo server to
relay messages to all participants. The requirements for this echo server are
not great. It should not have decryption capability, and as a result does not
need to maintain its own ratchet state. It merely needs to route messages based
on routing information supplied by the sending participant. Providing such routing
information will not leak additional metadata to an adversary, because the
adversary could also track the message flow along the connected graph, obtaining
the same information.

The connected graph network suffers from scalability issues - for large enough
groups, maintaining the ratchet state becomes very resource intensive. However,
we do not believe this is a significant disadvantage, because person-to-person
group conversations suffer from the same scalability problem. It  would be
unusual to see a group conversation between a number of participants larger
than \textit{e.g.} $N = 20$ or so. Larger conversations tend to break into
sub-conversations.
Extending SMMP to cover multiple sub-conversations with a group will be
described in a later paper.

Finally, we note that we have developed a reference
implementation\cite{ref:referenceimplementation} of SMMP. The reference
implementation uses an echo server to forward messages to users.
\begin{thebibliography}{99}
\bibitem{ref:bian} J. Bian, R. Seker, and U. Topaloglu ``Off-the-Record Instant
Messaging for Group Conversation," \textit{IRI '07: Proceedings of Information
Reuse and Integration,} pp. 79-84, IEEE Computer Society, 2007.

\bibitem{ref:goldberg} I. Goldberg, M. D. Van Gundy, B. Ustanoglu, and H. Chen,
``Multi-Party Off-the-Record Messaging," \textit{CSS '09: Proceedings of the
16th ACM Conference on Computer and Communication Security,} pp. 358-368, ACM,
2009.

\bibitem{ref:cryptocat} Cryptocat Messaging Blog
\url{https://github.com/cryptocat/mpotr}, accessed Feb. 22, 2014.

\bibitem{ref:liu} H. Liu, E. Y. Vasserman, and N. Hopper, ``Improved Group
Off-the-Record Messaging," \textit{WPES'13: Proceedings of the ACM Workshop on
Privacy in the Electronic Society,} ACM, 2013.

\bibitem{ref:burmester} M. Burmester and Y. Desmedt, ``A secure and efficient
conference key distribution system," \textit{EUROCRYPT'94: Advances in
Cryptology,} volume 950 of Lecture Notes in Computer Science, 1995.

\bibitem{ref:pidgin} ``Pidgin," \url{https://www.pidgin.im}, accessed Feb. 27,
2014.

\bibitem{ref:otr} ``Off the Record Messaging",
\url{https://otr.cypherpunks.ca/}, accessed Feb. 22, 2014.

\bibitem{ref:otr1} N. Borisov, I. Goldberg, and E. Brewer, ``Off-the-Record
Communication, or, Why Not To Use PGP," \textit{WPES'04: Proceedings of the
ACM Workshop on Privacy in the Electronic Society,} ACM, 2004.

\bibitem{ref:raimondo} M. D.Raimondo, R. Gennaro, and H. Krawczyk, ``Secure
Off-the-Record Messaging," \textit{WPES'05 Proceedings of the 2005 ACM Workshop
on Privacy in the Electronic Society,} pp. 81-89, ACM, 2005.

\bibitem{ref:otr2} C. Alexander and I. Goldberg, ``Improved User Authentication
in Off-The-Record Messaging," \textit{WPES'07: Proceeedings of the ACM Workshop
on Privacy in the Electronic Society,} ACM, 2007.

\bibitem{ref:otr3} R. Stedman, K. Yoshida, and I. Goldberg, ``A User Study of
Off-The-Record Messaging," \textit{SOUPS 2008: Symposium on Usable Privacy and
Security}, pp. 1-10, SOUPS, 2008.

\bibitem{ref:scimp}  Vinnie Moscaritolo, Gary Belvin, and Phil Zimmermann,
``Silent Circle Instant Messaging Protocol Protocol Specification",
\url{https://silentcircle.com/static/download/SCIMP%20paper.pdf}, accessed Feb.
22, 2014.

\bibitem{ref:axolotl} Trevor Perrin and Moxie Marlinspike, ``Axolotl Ratchet",
\url{https://github.com/trevp/axolotl/wiki/newversion}, accessed Feb. 22, 2014.

\bibitem{ref:referenceimplementation} D. R. Andersen, M. S. Andersland, and T.
J. Andersen, ``Reference implementation of SSMP: A Secure Multi-party Messaging
Protocol," \url{https://notpublicyet}, 2014.

\end{thebibliography}
\end{document}
%
% ****** End of file apssamp.tex ******
